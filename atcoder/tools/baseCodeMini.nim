import macros; macro minifiedTemplate(): untyped = parseStmt("import std/[sequtils, strutils, strformat, strscans, algorithm, math, sugar, hashes, tables, complex, random, deques, heapqueue, sets, macros]\n{. warning[UnusedImport]: off, hint[XDeclaredButNotUsed]: off, hint[Name]: off .}\n\n# {.since: (1, 1).}\ntemplate countIt*(s, pred: untyped): int =\n  var result = 0\n  for it {.inject.} in s:\n    if pred: result += 1\n  result\n# {.since: (1, 1).}\nfunc maxIndex*[T](s: openArray[T]): int =\n  for i in 1..high(s):\n    if s[i] > s[result]: result = i\n# {.since: (1, 5, 1).}\nfunc ceilDiv*[T: SomeInteger](x, y: T): T {.inline.} =\n  when sizeof(T) == 8:\n    type UT = uint64\n  elif sizeof(T) == 4:\n    type UT = uint32\n  elif sizeof(T) == 2:\n    type UT = uint16\n  elif sizeof(T) == 1:\n    type UT = uint8\n  else:\n    {.fatal: \"Unsupported int type\".}\n  assert x >= 0 and y > 0\n  when T is SomeUnsignedInt:\n    assert x + y - 1 >= x\n  ((x.UT + (y.UT - 1.UT)) div y.UT).T\n# {.since: (1, 5, 1).}\nfunc euclMod[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if result < 0:\n    result += abs(y)\n# {.since: (1, 3).} and Edited by me\nproc toDeque*[T](x: openArray[T]): Deque[T] =\n  result = initDeque()\n  for item in items(x):\n    result.addLast(item)\n\ntemplate newSeqWith*(len: int, init: untyped): untyped =\n  var result = newSeq[typeof(init, typeOfProc)](len)\n  for i in 0 ..< len:\n    result[i] = init\n  move(result) # refs bug #7295\nmacro toTuple(lArg: openArray, n: static[int]): untyped =\n  let l = genSym()\n  var t = newNimNode(nnkTupleConstr)\n  for i in 0..<n:\n    t.add quote do:\n      `l`[`i`]\n  quote do:\n    (let `l` = `lArg`; `t`)\n# 適当にコピペして来たHash https://github.com/nim-lang/Nim/issues/11764#issuecomment-611186437\nproc hiXorLo(a, b: uint64): uint64 {.inline.} =\n  {.emit: \"__uint128_t r=a; r*=b; `result` = (r>>64)^r;\".}\nproc hashWangYi1*(x: int64|uint64|Hash): Hash {.inline.} =\n  const P0 = 0xa0761d6478bd642f'u64\n  const P1 = 0xe7037ed1a0b428db'u64\n  const P5x8 = 0xeb44accab455d165'u64 xor 8'u64\n  Hash(hiXorLo(hiXorLo(P0, uint64(x) xor P1), P5x8))\nproc hash(x: int): Hash =\n  x.hashWangYi1()\nproc pow(x, n, m: int): int =\n  if n == 0:\n    return 1\n  if n mod 2 == 1:\n    result = x * pow(x, n-1, m)\n  else:\n    result = pow(x, n div 2, m)^2\n  result = result mod m\nproc `mod=`(x: var int, m: int): void =\n  x = x mod m\n\n################################\n\n")
minifiedTemplate()
